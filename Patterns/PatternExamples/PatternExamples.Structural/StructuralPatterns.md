# Structural Patterns  
## Adapter
წარმოვიდგინოთ რომ ვემუშავებით რაღაც ბანძ ძველ აპლიკაციას, რომელიც მონაცემთა მიმოცვლისთვის და ინფორმაციის შესანახად
XML ფორმატს იყენებს. ახლა წარმოვიდგინოთ რომ ამ აპლიკაციაში ახალი ბიბლიოთეკის დამატება გვინდა, რომელიც
ჩვენს მონაცემებს ლამაზად დახატავს და სხვადასხვა ჩარტებისა თუ ნახაზების სახით წარმოადგენს. იდეა კარგია მაგრამ
ასევე აღმოჩნდა რომ ეს ბიბლიოთეკა json სახის მონაცემებზე მუშაობს მხოლოდ და XML არ გვაწყობს. ორი ვარიანტი
გვაქვს:
1. გადავწეროთ აპლიკაცია ისე რომ json ფორმატზე იმუშავოს (რაც ფაქტობრივად მისაღები არაა)
2. შევქმნათ ერთგვარი გადამყვანი ამ ბიბლიოთეკისთვის, რომელიც ჩვენს მონაცემებს xml დან json ში გადაიყვანს
და ისე აჭმევს ამ ბიბლიოთეკას 

რა თქმა უნდა, მეორე ვარიანტი უფრო გამოგვადგება ამ ქეისში ვიდრე პირველი,
ვინაიდან ყველამ ვიცით რა ტკივილია ლეგასი ფუნქციონალის გადაწერა. ზუსტად ასეთ
ქეისებში ვიყენებთ Adapter pattern ს.

<img alt="image" src="Images/adapter1.png"/>

ზემოთ მოცემულ მაგალითში:
1. Client არის კლასი რომელშიც ძირითადი ბიზნეს ლოგიკა წერია
2. Client Interface არის ამ კლიენტის ინტერფეისი სადაც მისი მეთოდებია
აღწერილი
3. Service არის რაღაც გამოსადეგი 3rd party ან ნებისმიერი სერვისი
რომელიც მიმდინარე ლოგიკით არ გვადგება, თუმცა გვჭირდება.
4. Adapter კლასია რომელსაც შეუძლია ემუშავოს როგორც Client ს ასევე
Service ს და აიძულოს მათ კოლაბორაცია.

შეგვიძლია იგივე ქეისის კოდის მაგალითიც ვნახოთ.

## Bridge

ბრიჯი არის სტრუქტურული დიზაინ პატერნი, რომელიც საშუალებას გვძლევს ორად დავყოთ ერთი დიდი კლასი ან ერთმანეთთან
დაკავშირებული კლასები ორ ცალცალკე იერარქიად, რომლებიც დამოუკიდებლად განვითარდებიან. ერთი იერარქია აბსტრაქცია იქნება ხოლო მეორე
იმპლემენტაცია. 

რთულად ჟღერს? მოდი ვნახოთ მარტივი მაგალითი:

ვთქვათ გვაქვს კლასი Shape და მისი 2 საბკლასი Circle და Square. ამ იერარქიაში მოგვინდა გაგვეჩინა ფერის ცნება.
გამომდინარე აქედან პირდაპირი გზა გვაქვს რომ შევქმნათ წითელი და ლურჯი წრის და კვადრატის კლასები. გამომდინარე აქედან
დაგვჭირდება შევქმნათ 4 Shape ის საბკლასი. ამ იერარქიაში ახალი ფორმის ტიპისა და ფერის დამატება გამოიწვევს კლასების რაოდენობის
უაზრო ზრდას.  
ამ კონკრეტულ შემთხვევაში პრობლემა იმაშია რომ ჩვენ ვცდილობთ Shape კლასის განგრძობას ორი დამოუკიდებელი განზომილების მიხედვით,
ფორმითა და ფერით. Bridge პატერნი ამ პრობლემის გადაჭრის ცდილობს მემკვიდრეობის კომპოზიციით ჩანაცვლებით. 
ამ მიდგომით ორიგინალ Shape კლასში გვექნება რეფერენსი ფერზე და ბევრი კლასების კომბინაციის შექმნა აღარ მოგვიწევს.

ამ მიდგომას თუ გავყვებით შეგვიძლია Shape და ფერთან დაკავშირებული ლოგიკა ერთმანეთისგან განვაცალკევოთ და შევქმნათ
Color კლასი, რომელსაც ორი შვილობილი ეყოლება წითელი და ლურჯი. Shape კლასში ამის შემდეგ ჩაემატება Reference 
Color კლასზე. ამის შემდეგ Shape კლასს შეუძლია ნებისმიერი ფერთან დაკავშრებული საქმე დააკისროს Color კლასს. ასევე ახალი ფერების
დამატება ამის შემდეგ აღარ მოითხოვს ახალი კლასების შექმნას.

### Abstraction and implementation

Gang Of Four წიგნში აბსტრაქცია და იმპლემენტაცია წარმოდგენილია როგორც Bridge პატერნის აღწერა. თუმცაღა მოდი 
ვთქვათ რომ ეს განმარტება მარტივად აღსაქმელი არაა. მოდი იგი თავიდან განვმარტოთ.  

აბსტრაქცია არის რაღაც ენთითის ზედა დონის მართვის შრე (ლეიერი). მას დამოუკიდებლად არაფრის გაკეთება არ უნდა
შეეძლოს და რეალური საქმე იმპლემენტაციას უნდა გადაულოცოს. მაინც აღვნიშნავ რომ აბსტრაქციასა და იმპლემენტაციაში
C# ის აბსტრაქტ კლასი და ინტერფეისი არ იგულისხმება. აპლიკაციებზე საუბრისას აბსტრაქცია შეიძლება ნიშნავდეს GUI ს 
ხოლო იმპლემენტაცია მის უკან მდგომ API ს. რომ შევაჯამოთ მსგავსი აპლიკაცია ორნაირად შეიძლება განვითარდეს: 

* გვაქვს რანდენიმე GUI (მომხმარებლების, ადმინების ა.შ.)
* გვაქვს რამდენიმე API (სხვადასხვა OS ზე გასაშვებად და ა.შ. ???)

უარეს შემთხვევაში ეს აპლიკაცია შეიძლება გახდეს დიდი აჯაფსანდალი სადაც ბევრი if და switch ებით წყდება სად რა
API გამოვიძახოთ და რომელი GUI ჩავტვირთოთ. ამ არეულობის დალაგება შეგვიძლია ვცადოთ კონკრეტულ ინტერფეისთან
დაკავშირებული კოდის ცალკე გატანით. თუმცა ამის მცდელობისას აღმოვაჩენთ რომ ბევრ კლასებს ვქმნით. ასევე აღმოვაჩენთ,
რომ უფრო და უფრო მეტი კლასის შექმნა გვიწევს ახალი ინტერფეისების ან API ების დამატებისას. მოდი ამ პრობლემის მოგვარება
ვცადოთ Bridge პატერნით. ამ პატერნის მიხედვით ჩვენ უნდა დავყოთ კლასები ორ იერარქიად:

* აბსტრაქცია
* იმპლემენტაცია

აბსტრაქტული ობიექტი ჩვენს მაგალითში აკონტროლებს აპლიკაციის ვიზუალს. იგი მხოლოდ რეალური საქმის დელეგირებას აკეთებს.
ამ დროს სხვადასხვა იმპლემენტაციების გამოყენება შეგვიძლია თუ ეს იმპლემენტაციები არ არღვევენ ინტერფეისს და საშუალებას აძლევენ
GUI ს იმუშავოს სხვადასხვა პლატფორმასთან. 

უფრო პრაქტიკული მაგალითი რომ განვიხილოთ შეგვიძ₾ია მაგალითად ავიღოთ ტელევიზორი. თავდაპირველად ტელევიზორი მონოლითი იყო
იგი ერთი დიდი და სქელი ეკრანი იყო რომელსაც გვერდითვე ჰქონდა 2 ღილაკი ხმის ასაწევ ჩასაწევად და არხის შესაცვლელად. 
დროთა განმავლობაში ტელევიზორის სამართავად მეტი მოთხოვნები გაჩნდა და ტელევიზორზევე ღილაკების მატება პრაქტიკული არ იყო, 
სხვა მიზეზებთან ერთად ამიტომ გაჩნდა პულტი ცალკე მოწყობილობად. ამის შემდეგ პულტს და ტელევიზორს ერთმანეთის დამოუკიდებლად
შეუძლიათ განვითარება. ახლა უკვე შესაძლებელია ერთი პულტით რამდენიმე მოწყობილბოაც კი ვმართოთ.