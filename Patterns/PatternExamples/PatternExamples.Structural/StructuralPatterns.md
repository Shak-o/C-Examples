# Structural Patterns  
## Adapter
წარმოვიდგინოთ რომ ვემუშავებით რაღაც ბანძ ძველ აპლიკაციას, რომელიც მონაცემთა მიმოცვლისთვის და ინფორმაციის შესანახად
XML ფორმატს იყენებს. ახლა წარმოვიდგინოთ რომ ამ აპლიკაციაში ახალი ბიბლიოთეკის დამატება გვინდა, რომელიც
ჩვენს მონაცემებს ლამაზად დახატავს და სხვადასხვა ჩარტებისა თუ ნახაზების სახით წარმოადგენს. იდეა კარგია მაგრამ
ასევე აღმოჩნდა რომ ეს ბიბლიოთეკა json სახის მონაცემებზე მუშაობს მხოლოდ და XML არ გვაწყობს. ორი ვარიანტი
გვაქვს:
1. გადავწეროთ აპლიკაცია ისე რომ json ფორმატზე იმუშავოს (რაც ფაქტობრივად მისაღები არაა)
2. შევქმნათ ერთგვარი გადამყვანი ამ ბიბლიოთეკისთვის, რომელიც ჩვენს მონაცემებს xml დან json ში გადაიყვანს
და ისე აჭმევს ამ ბიბლიოთეკას 

რა თქმა უნდა, მეორე ვარიანტი უფრო გამოგვადგება ამ ქეისში ვიდრე პირველი,
ვინაიდან ყველამ ვიცით რა ტკივილია ლეგასი ფუნქციონალის გადაწერა. ზუსტად ასეთ
ქეისებში ვიყენებთ Adapter pattern ს.

<img alt="image" src="Images/adapter1.png"/>

ზემოთ მოცემულ მაგალითში:
1. Client არის კლასი რომელშიც ძირითადი ბიზნეს ლოგიკა წერია
2. Client Interface არის ამ კლიენტის ინტერფეისი სადაც მისი მეთოდებია
აღწერილი
3. Service არის რაღაც გამოსადეგი 3rd party ან ნებისმიერი სერვისი
რომელიც მიმდინარე ლოგიკით არ გვადგება, თუმცა გვჭირდება.
4. Adapter კლასია რომელსაც შეუძლია ემუშავოს როგორც Client ს ასევე
Service ს და აიძულოს მათ კოლაბორაცია.

შეგვიძლია იგივე ქეისის კოდის მაგალითიც ვნახოთ.

## Bridge

ბრიჯი არის სტრუქტურული დიზაინ პატერნი, რომელიც საშუალებას გვძლევს ორად დავყოთ ერთი დიდი კლასი ან ერთმანეთთან
დაკავშირებული კლასები ორ ცალცალკე იერარქიად, რომლებიც დამოუკიდებლად განვითარდებიან. ერთი იერარქია აბსტრაქცია იქნება ხოლო მეორე
იმპლემენტაცია. 

რთულად ჟღერს? მოდი ვნახოთ მარტივი მაგალითი:

ვთქვათ გვაქვს კლასი Shape და მისი 2 საბკლასი Circle და Square. ამ იერარქიაში მოგვინდა გაგვეჩინა ფერის ცნება.
გამომდინარე აქედან პირდაპირი გზა გვაქვს რომ შევქმნათ წითელი და ლურჯი წრის და კვადრატის კლასები. გამომდინარე აქედან
დაგვჭირდება შევქმნათ 4 Shape ის საბკლასი. ამ იერარქიაში ახალი ფორმის ტიპისა და ფერის დამატება გამოიწვევს კლასების რაოდენობის
უაზრო ზრდას.  
ამ კონკრეტულ შემთხვევაში პრობლემა იმაშია რომ ჩვენ ვცდილობთ Shape კლასის განგრძობას ორი დამოუკიდებელი განზომილების მიხედვით,
ფორმითა და ფერით. Bridge პატერნი ამ პრობლემის გადაჭრის ცდილობს მემკვიდრეობის კომპოზიციით ჩანაცვლებით. 
ამ მიდგომით ორიგინალ Shape კლასში გვექნება რეფერენსი ფერზე და ბევრი კლასების კომბინაციის შექმნა აღარ მოგვიწევს.

ამ მიდგომას თუ გავყვებით შეგვიძლია Shape და ფერთან დაკავშირებული ლოგიკა ერთმანეთისგან განვაცალკევოთ და შევქმნათ
Color კლასი, რომელსაც ორი შვილობილი ეყოლება წითელი და ლურჯი. Shape კლასში ამის შემდეგ ჩაემატება Reference 
Color კლასზე. ამის შემდეგ Shape კლასს შეუძლია ნებისმიერი ფერთან დაკავშრებული საქმე დააკისროს Color კლასს. ასევე ახალი ფერების
დამატება ამის შემდეგ აღარ მოითხოვს ახალი კლასების შექმნას.

### Abstraction and implementation

Gang Of Four წიგნში აბსტრაქცია და იმპლემენტაცია წარმოდგენილია როგორც Bridge პატერნის აღწერა. თუმცაღა მოდი 
ვთქვათ რომ ეს განმარტება მარტივად აღსაქმელი არაა. მოდი იგი თავიდან განვმარტოთ.  

აბსტრაქცია არის რაღაც ენთითის ზედა დონის მართვის შრე (ლეიერი). მას დამოუკიდებლად არაფრის გაკეთება არ უნდა
შეეძლოს და რეალური საქმე იმპლემენტაციას უნდა გადაულოცოს. მაინც აღვნიშნავ რომ აბსტრაქციასა და იმპლემენტაციაში
C# ის აბსტრაქტ კლასი და ინტერფეისი არ იგულისხმება. აპლიკაციებზე საუბრისას აბსტრაქცია შეიძლება ნიშნავდეს GUI ს 
ხოლო იმპლემენტაცია მის უკან მდგომ API ს. რომ შევაჯამოთ მსგავსი აპლიკაცია ორნაირად შეიძლება განვითარდეს: 

* გვაქვს რანდენიმე GUI (მომხმარებლების, ადმინების ა.შ.)
* გვაქვს რამდენიმე API (სხვადასხვა OS ზე გასაშვებად და ა.შ. ???)

უარეს შემთხვევაში ეს აპლიკაცია შეიძლება გახდეს დიდი აჯაფსანდალი სადაც ბევრი if და switch ებით წყდება სად რა
API გამოვიძახოთ და რომელი GUI ჩავტვირთოთ. ამ არეულობის დალაგება შეგვიძლია ვცადოთ კონკრეტულ ინტერფეისთან
დაკავშირებული კოდის ცალკე გატანით. თუმცა ამის მცდელობისას აღმოვაჩენთ რომ ბევრ კლასებს ვქმნით. ასევე აღმოვაჩენთ,
რომ უფრო და უფრო მეტი კლასის შექმნა გვიწევს ახალი ინტერფეისების ან API ების დამატებისას. მოდი ამ პრობლემის მოგვარება
ვცადოთ Bridge პატერნით. ამ პატერნის მიხედვით ჩვენ უნდა დავყოთ კლასები ორ იერარქიად:

* აბსტრაქცია
* იმპლემენტაცია

აბსტრაქტული ობიექტი ჩვენს მაგალითში აკონტროლებს აპლიკაციის ვიზუალს. იგი მხოლოდ რეალური საქმის დელეგირებას აკეთებს.
ამ დროს სხვადასხვა იმპლემენტაციების გამოყენება შეგვიძლია თუ ეს იმპლემენტაციები არ არღვევენ ინტერფეისს და საშუალებას აძლევენ
GUI ს იმუშავოს სხვადასხვა პლატფორმასთან. 

უფრო პრაქტიკული მაგალითი რომ განვიხილოთ შეგვიძ₾ია მაგალითად ავიღოთ ტელევიზორი. თავდაპირველად ტელევიზორი მონოლითი იყო
იგი ერთი დიდი და სქელი ეკრანი იყო რომელსაც გვერდითვე ჰქონდა 2 ღილაკი ხმის ასაწევ ჩასაწევად და არხის შესაცვლელად. 
დროთა განმავლობაში ტელევიზორის სამართავად მეტი მოთხოვნები გაჩნდა და ტელევიზორზევე ღილაკების მატება პრაქტიკული არ იყო, 
სხვა მიზეზებთან ერთად ამიტომ გაჩნდა პულტი ცალკე მოწყობილობად. ამის შემდეგ პულტს და ტელევიზორს ერთმანეთის დამოუკიდებლად
შეუძლიათ განვითარება. ახლა უკვე შესაძლებელია ერთი პულტით რამდენიმე მოწყობილბოაც კი ვმართოთ.

## Composite

კომპოზიტი არის დიზაინ პატერნი, რომელიც საშუალებას გვაძლევს ჩვენი ობიექტები მოვაწყოთ ხის სტრუქტურის მსგავსად.
კომპოზიტ პატრენის გამოყენებას მაშინ აქვს აზრი როცა ჩვენი ფუნქციონალის ძირითადი მოდელი წარმოდგენადია, როგორც
ხის სტრუქტურა. 

მაგალითად, წარმოვიდგინოთ რომ აპლიკაციაში გვაქვს ორი სახის ობიექტი: პროდუქტი და ყუთი. ყუთში შეიძლება გვქონდეს სხვა
პროდუქტებიც და შედარებით პატარა ყუთებიც. ამ პატარა ყუთებში ასევე შიძლება იყოს კიდევ სხვა პროდუქტები და სხვა პატარა
ყუთები და ა.შ. 

ვთქვათ ამ სისტემისთვის გადავწყვიტეთ შეკვეთების სიტემის ჩამატება ჩვენს აპლიკაციაში. შეკვეთაში შეიძლება იყოს როგორც უბრალოდ
ერთი პროდუქტი ასევე ყუთი მთელი თავისი შიგთავსით. ამ პროდუქტების სრულ ფასს როგორ დავთვლიდით? 
შეგვიძლია ყველაზე მარტივად წარმოსადგენი და პირდაპირი მიდგომა გამოვიყენოთ: გავხსნათ ყველა ყუთი და სათითაოდ დავაჯამოთ
მასში არსებული პროდუქტების ფასი, ამ ყუთში არსებული დანარჩენი ყუთებიც ასევე გავხსნათ და შევაჯამოთ მათი პროდუქტების ფასი
და ა.შ. რეალურ ცხოვრებაში ამის გაკეთება შესაძლებელია, მოსაწყენია მაგრამ შესაძლებელი. მაგრამ აპლიკაციაში ამ მიდგომის იმპლემენტაციისას
გადავაწყდებით პრობლემებს. მაგალითად, ჩვენ უნდა ვიცოდეთ ყველა ყუთისა და პროდუქტის ტიპი, როცა ამ მიდგომას გამოვიყენებთ, ასევე
უნდა ვიცოდეთ რა დონეზე არის ჩადგმული ეს ყუთები ერთმანეთში და სხვა ათასი დეტალი რომ ჩვენი აპლიკაცია როგორღაც ავამუშავოთ.

ამ შემთხვევაში კომპოზიტ პატერნი გვირჩევს რომ პროდუქტებთან და ყუთებთან სამუშაოდ გამოვიყენოთ ერთიდაიგივე ინტერფეისი
რომელშიც გამოცხადებული იქნება ჯამური ფასის დათვლის მეთოდი. 
პროდუქტებისთვის ეს მეთოდი პირდაპირ ფასს დააბრუნებს, ხოლო ყუთებისთვის იგი ჩამოუვლის ყველა პროდუქტს, გამოიძახებს იგივე
მეთოდს და აჯამავს ფასს. თუ ისევ ყუთი შეგვხვდება ყუთში ამ შემთხვევაშიც ისევ ჯამური ფასის დათვლის მეთოდი გამოიძახება,
რომელიც უკვე ამ ჩადგმული ყუთის პროდუქტების ფასის შეკრებას დაიწყებს და ა.შ. ასე გაგრძელდება სანამ ყველაფრის ფასი არ დაითვლება.

ამ მიდგომის ბენეფიტი ისაა, რომ არ გვაღელვებს კონკრეტულად რა კლასებს ვემუშავებით ხეში. სხვადასხვა პროდუქტი იქნება თუ ყუთი
ვიცით რომ ყველა მათგანს ერთი საერთო მეთოდი ექნება და მისი დახმარებით შეგვიძლია საჭირო საქმე შევასრულოთ.

### Pros and Cons:
* ✅ შეგვიძლია ვემუშავოთ კომპლექსურ ხის სტრუქტრურებს უფრო მოხერხებულად. გამოვიყენებთ პოლიმორფიზმსა და რეკურსიას ჩვენთვის სასიკეთოდ
* ✅ დავიცავთ Open/Closed პრინციპს. შეგვიძლია ჩვენს ფუნქციონალში გავაჩნოთ ახალი ელემენტები და ლოგიკა არსებულის გაუფუჭებლად


* ❌ ხშირ შემთხვევაში რთული იქნება ისეთი კლასების საერთო ინტერფეისზე მორგება, რომლებიც საკმაოდ განსხვავებულ ფუნქციებს ასრულებენ.
ამის გამო მოგვიწევს ინტერფეისის უფრო და უფრო განზოგადება, რაც გაართულებს საქმეს.

### სხვა პატერნებთან დამოკიდებულებები
* You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.

* Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.

* You can use Iterators to traverse Composite trees.

* You can use Visitor to execute an operation over an entire Composite tree.

* You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.

* Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.

* A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.

* However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.

* Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.